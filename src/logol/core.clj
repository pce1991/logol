(ns logol.core
  (:require [clojure.string :as s]))

;;; The goal of this library being to find patterns like these in literature
;;; and other instances of text (especially records of unscripted spoken dialogue) 


(defn strings->regex [strings]
  (re-pattern (s/join  (interpose "|" strings))))

;;; change these next 2 so that they return true or the disqualifying letters
;;; this will let me know how far they are from succeeding.

;;; if its false return which letters were found? return empty if none were?
(defn lipogram? [string omitions]
  "Returns true if the string contains none of the characters in omitions"
  (empty? (re-find (strings->regex omitions) string)))

;;; returns true if the word contains all letters and if not returns which
;;; its missing. An odd way to handle booleans since it'll always be true
;;; use to see words containing all five vowels.
(defn word-contains? [string letters]
  "Returns true if word contains them all and false if not"
  (empty?
   (filter nil? (map re-find (map re-pattern letters)
                     (repeat (count letters) string)))))

(defn words [string]
  (s/split (s/lower-case string) #" "))

;;; change these four functions to take a string and turn it into words
(defn first-letters [words]
  "Takes a seq of words and returns a seq of the first letters of each word"
  (map str (map first words)))

(defn last-letters [words]
  (map str (map last words)))

(defn first-nth-letters [words n]
  "Returns the first n letters where n is less than the length of the word, and if greater returns the whole word."
  (map #(subs % 0 (if (> n (count %))
                    (count %)
                    n))
       words))

(defn last-nth-letters [words n]
  (map #(subs % (if (< n (count %))
                  (- (count %) n)
                  0))
       words))

;;; a scheme can be generated by using every character in the string (ignoring spaces). What other kind of kinds of schemes can be generated?
(defn generate-scheme [string]
  "Generates a scheme from a string, ignoring whitespace."
  (map s/lower-case (remove #(= % " ") (s/split string #""))))

;;; scheme may just be a seq of letters which must pair up with the string
;;; what if they arent the same length? throw an error, or wrap around
;;; allow scheme to be a word, and if it is generate a scheme on it.
;;; allow spill over, showing which words didnt fit scheme or the runoff
;;; of the scheme that didnt match up against the words. 
(defn acrostic? [string scheme]
  (let [w (words string)
        letters (first-letters w)
        s (if (string? scheme)
            (generate-scheme scheme)
            scheme)]
    (cond (= (count scheme) (count letters))
          (= scheme letters)
          (< (count scheme) (count letters))
          (= letters (repeat (/ (count letters) (count scheme)) scheme))
          ;; scheme may excede or fall short of letter-count, allow overflow?
          (> (count scheme) (count letters))
          false ;maybe allow overflow acrostic, so it fits most of the pattern but not all.
          ;; how to handle first letter of each line spelling out something?
          ;; just give it the first letter of each line.
          ;; what about each word beginning with the end of the last word
          ;; to the nth place. 
          )))







